"""Service for reading/writing the notify_transcoder.sh bash script."""

from __future__ import annotations

import logging
import os
import re

from backend.config import settings

log = logging.getLogger(__name__)

SCRIPT_FILENAME = "notify_transcoder.sh"
ARM_SIDE_CONFIG_DIR = "/etc/arm/config"

SCRIPT_TEMPLATE = r'''#!/usr/bin/env bash
# notify_transcoder.sh - Send ARM notifications to arm-transcoder with authentication
#
# ARM calls this script with two positional arguments:
#   $1 = title (e.g. "ARM notification")
#   $2 = body  (e.g. "Movie Title (2024) rip complete. Starting transcode.")
#
# ARM (neu) also sets environment variables:
#   ARM_RAW_PATH     - Actual raw MKV output directory (e.g. /home/arm/media/raw/SERIAL_MOM)
#   ARM_JOB_ID       - ARM database job ID
#   ARM_TITLE        - User-corrected title (or auto-detected if not corrected)
#   ARM_TITLE_AUTO   - Auto-detected title from disc label
#
# Generated by ARM UI — edit variables below or regenerate from Settings > Transcoder.

# Configuration: Set these to match your arm-transcoder setup
TRANSCODER_URL="http://TRANSCODER_IP:5000/webhook/arm"
WEBHOOK_SECRET=""  # Set this to match WEBHOOK_SECRET in arm-transcoder's .env

# Local scratch storage: when both are set, ripped files are moved from
# local disk to shared storage before notifying the transcoder.
# Leave empty to skip (ARM writes directly to shared storage).
LOCAL_RAW_PATH=""   # Local disk where ARM rips to (e.g. /home/arm/media/raw)
SHARED_RAW_PATH=""  # Shared storage handoff location (e.g. /mnt/media/raw)

TITLE="${1:-}"
BODY="${2:-}"

if [ -z "$BODY" ]; then
    echo "Usage: $0 <title> <body>" >&2
    exit 1
fi

# ARM (neu) passes the actual raw path via environment variable.
# This is more reliable than extracting the title directory from body text.
RAW_PATH="${ARM_RAW_PATH:-}"

# Move ripped files from local scratch -> shared storage (if configured)
if [ -n "$LOCAL_RAW_PATH" ] && [ -n "$SHARED_RAW_PATH" ]; then
    if [ -n "$RAW_PATH" ]; then
        # Use the directory basename from ARM_RAW_PATH
        TITLE_DIR="$(basename "$RAW_PATH")"
    else
        # Fallback: extract title directory from body text
        TITLE_DIR=""
        if [[ "$BODY" =~ ^(.+)[[:space:]]rip\ complete ]]; then
            TITLE_DIR="${BASH_REMATCH[1]}"
        elif [[ "$BODY" =~ ^(.+)[[:space:]]processing\ complete ]]; then
            TITLE_DIR="${BASH_REMATCH[1]}"
        fi
    fi

    if [ -n "$TITLE_DIR" ]; then
        SRC="$LOCAL_RAW_PATH/$TITLE_DIR"
        DST="$SHARED_RAW_PATH/$TITLE_DIR"
        if [ -d "$SRC" ]; then
            mkdir -p "$SHARED_RAW_PATH"
            mv "$SRC" "$DST"
            echo "Moved $SRC -> $DST"
            # Update RAW_PATH to reflect the new location
            RAW_PATH="$DST"
        else
            echo "WARNING: Local source not found: $SRC" >&2
        fi
    fi
fi

# Escape strings for safe JSON embedding
json_escape() {
    printf '%s' "$1" | python3 -c 'import json,sys; print(json.dumps(sys.stdin.read()), end="")'
}

# Build JSON payload — include path basename if available from ARM_RAW_PATH.
# The transcoder expects a directory name only (no slashes) and prepends its own RAW_PATH.
if [ -n "$RAW_PATH" ]; then
    PATH_BASENAME="$(basename "$RAW_PATH")"
    JSON_PAYLOAD="{\"title\": $(json_escape "$TITLE"), \"body\": $(json_escape "$BODY"), \"path\": $(json_escape "$PATH_BASENAME"), \"type\": \"info\"}"
else
    JSON_PAYLOAD="{\"title\": $(json_escape "$TITLE"), \"body\": $(json_escape "$BODY"), \"type\": \"info\"}"
fi

# Build curl command
CURL_ARGS=(
    -s
    -X POST
    -H "Content-Type: application/json"
)

# Add webhook secret header if configured
if [ -n "$WEBHOOK_SECRET" ]; then
    CURL_ARGS+=(-H "X-Webhook-Secret: ${WEBHOOK_SECRET}")
fi

CURL_ARGS+=(-d "$JSON_PAYLOAD" "$TRANSCODER_URL")

RESPONSE=$(curl "${CURL_ARGS[@]}" -w "\n%{http_code}" 2>&1)
HTTP_CODE=$(echo "$RESPONSE" | tail -1)
RESP_BODY=$(echo "$RESPONSE" | head -n -1)

if [ "$HTTP_CODE" -ge 200 ] 2>/dev/null && [ "$HTTP_CODE" -lt 300 ] 2>/dev/null; then
    echo "Notification sent to arm-transcoder (HTTP ${HTTP_CODE})"
else
    echo "Failed to notify arm-transcoder (HTTP ${HTTP_CODE}): ${RESP_BODY}" >&2
    exit 1
fi
'''

# Variable names we extract/substitute in the script
_VARIABLES = ["TRANSCODER_URL", "WEBHOOK_SECRET", "LOCAL_RAW_PATH", "SHARED_RAW_PATH"]

# Mapping from script variable names to dict keys
_VAR_KEY_MAP = {
    "TRANSCODER_URL": "transcoder_url",
    "WEBHOOK_SECRET": "webhook_secret",
    "LOCAL_RAW_PATH": "local_raw_path",
    "SHARED_RAW_PATH": "shared_raw_path",
}


def _get_local_script_path() -> str:
    """Path where the script lives on disk (alongside arm.yaml)."""
    return os.path.join(os.path.dirname(settings.arm_config_path), SCRIPT_FILENAME)


def _get_arm_side_path() -> str:
    """Path that ARM sees inside its container."""
    return os.path.join(ARM_SIDE_CONFIG_DIR, SCRIPT_FILENAME)


def _parse_variables(content: str) -> dict:
    """Extract configurable variables from script content."""
    result = {
        "transcoder_url": "",
        "webhook_secret": "",
        "local_raw_path": "",
        "shared_raw_path": "",
    }
    for var_name, key in _VAR_KEY_MAP.items():
        m = re.search(rf'^{var_name}="([^"]*)"', content, re.MULTILINE)
        if m:
            result[key] = m.group(1)
    return result


def read_script() -> dict:
    """Read the notification script and parse its variables."""
    path = _get_local_script_path()
    arm_path = _get_arm_side_path()

    if not os.path.isfile(path):
        return {
            "script_exists": False,
            "arm_path": arm_path,
            "variables": None,
            "content": None,
        }

    try:
        with open(path) as f:
            content = f.read()
        variables = _parse_variables(content)
        return {
            "script_exists": True,
            "arm_path": arm_path,
            "variables": variables,
            "content": content,
        }
    except OSError as e:
        log.warning("Failed to read script %s: %s", path, e)
        return {
            "script_exists": False,
            "arm_path": arm_path,
            "variables": None,
            "content": None,
        }


def write_script(
    transcoder_url: str,
    webhook_secret: str = "",
    local_raw_path: str = "",
    shared_raw_path: str = "",
) -> dict:
    """Generate the notification script with the given variables and write it."""
    arm_path = _get_arm_side_path()
    content = SCRIPT_TEMPLATE

    replacements = {
        "TRANSCODER_URL": transcoder_url,
        "WEBHOOK_SECRET": webhook_secret,
        "LOCAL_RAW_PATH": local_raw_path,
        "SHARED_RAW_PATH": shared_raw_path,
    }

    for var_name, value in replacements.items():
        content = re.sub(
            rf'^({var_name}=")[^"]*(")',
            rf"\g<1>{re.escape(value)}\g<2>",
            content,
            flags=re.MULTILINE,
        )

    path = _get_local_script_path()
    try:
        with open(path, "w") as f:
            f.write(content)
        os.chmod(path, 0o755)
        log.info("Wrote notification script to %s", path)
        return {"success": True, "arm_path": arm_path}
    except OSError as e:
        log.error("Failed to write script %s: %s", path, e)
        return {"success": False, "error": str(e)}
